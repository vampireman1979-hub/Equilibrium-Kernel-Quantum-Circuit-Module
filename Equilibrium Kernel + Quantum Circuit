#!/usr/bin/env python3
"""
Equilibrium Kernel + Quantum Circuit
------------------------------------

Implements:

    E_s(chi) = (T_A(chi) + T_B(chi)) / (2 * Phi(chi))

and maps E_s(chi) to a phase angle theta(chi) in [0, 2π)
for use as the parameter of RZ rotations in a 3-qubit
entangled (GHZ-like) circuit.
"""

import numpy as np

try:
    from qiskit import QuantumCircuit
except ImportError:
    QuantumCircuit = None


# ---------- 1. Equilibrium kernel ----------

def validate_chi(chi: float) -> None:
    """Basic domain checks for chi."""
    if chi < 0.0:
        raise ValueError("chi must be non-negative.")
    if chi > 1e7:
        print("Warning: chi is very large; model assumptions may not hold.")


def T_A(chi: float) -> float:
    """Example model for subsystem A temperature."""
    T_env = 300.0
    return T_env + 20.0 * np.exp(-chi / 1e4)


def T_B(chi: float) -> float:
    """Example model for subsystem B temperature."""
    T_env = 300.0
    return T_env - 15.0 * np.exp(-chi / 8e3)


def Phi(chi: float) -> float:
    """Example model for a non-zero scaling field Phi(chi)."""
    return 1.0 + 0.1 * np.tanh(chi / 1e4)


def equilibrium_score(chi: float) -> float:
    r"""
    E_s(chi) = (T_A(chi) + T_B(chi)) / (2 * Phi(chi))
    """
    validate_chi(chi)
    ta = T_A(chi)
    tb = T_B(chi)
    phi = Phi(chi)

    eps = 1e-12
    if abs(phi) < eps:
        raise ValueError(f"Phi(chi) too close to zero: {phi}")

    return (ta + tb) / (2.0 * phi)


def normalize_angle(theta: float) -> float:
    """Normalize any real angle to [0, 2π)."""
    return float(theta % (2.0 * np.pi))


def angle_from_equilibrium(chi: float) -> float:
    """
    Map E_s(chi) to a phase angle theta(chi) in [0, 2π).

    Uses the fractional part of E_s(chi) to ensure boundedness.
    """
    Es = equilibrium_score(chi)
    frac = Es % 1.0          # keep in [0, 1)
    theta = frac * 2.0 * np.pi
    return normalize_angle(theta)


# ---------- 2. Quantum circuit interface ----------

def build_equilibrium_circuit(chi: float):
    """
    Build a 3-qubit GHZ-like circuit parameterized by theta(chi).

    Qubit ordering: [0, 1, 2]

    - H on qubit 2.
    - CX(2 -> 0) and CX(2 -> 1) create a GHZ-like entangled state.
    - RZ(theta) on qubits 0 and 1, where theta is derived from E_s(chi).

    Returns:
        QuantumCircuit instance, or raises RuntimeError if Qiskit is missing.
    """
    if QuantumCircuit is None:
        raise RuntimeError("Qiskit is not installed. Install 'qiskit' to build circuits.")

    theta = angle_from_equilibrium(chi)

    qc = QuantumCircuit(3)
    qc.h(2)
    qc.cx(2, 0)
    qc.cx(2, 1)
    qc.rz(theta, 0)
    qc.rz(theta, 1)
    qc.barrier()

    return qc, theta


# ---------- 3. Reference run (chi → 60106) ----------

CHI_STAR = 60106.0

if __name__ == "__main__":
    print(f"chi*                 = {CHI_STAR}")
    Es_val = equilibrium_score(CHI_STAR)
    theta_val = angle_from_equilibrium(CHI_STAR)
    print(f"E_s(chi*)            = {Es_val}")
    print(f"theta(chi*)          = {theta_val} rad")
    print(f"theta(chi*) / 2π     = {theta_val / (2.0 * np.pi)}")

    if QuantumCircuit is None:
        print("
Qiskit not installed: circuit hook defined but not executed.")
    else:
        qc, theta_used = build_equilibrium_circuit(CHI_STAR)
        print("
Equilibrium-parameterized circuit:")
        print(qc.draw(output="text"))
